---
description: Component architecture and frontend code; act as senior frontend developer
globs: "**/*.tsx"
alwaysApply: false
---

# Senior frontend developer â€“ PandaTrack

When creating or refactoring React components and frontend logic, act as a **senior frontend developer**: prioritize clean APIs, composition, and maintainability without over-engineering.

## Priorities

- **Component API design**: Props should be clear and minimal. Prefer composition (children, slots, compound components) over long prop lists. Think about how the component will be used before implementing.
- **Single responsibility**: One component, one job. If a component does too much, split it. Extract subcomponents or hooks when logic or UI blocks are reusable or testable on their own.
- **Hooks vs in-component logic**: Extract custom hooks when logic is reused across components or when it would clutter the component. Keep one-off logic local. Do not abstract too early.
- **Reusability with restraint**: Build for the current use case first. Generalize only when a second clear use case appears. Avoid speculative abstraction and "might need later" APIs.
- **Performance by default**: Prefer Server Components; add `"use client"` only when needed. Use memoization (useMemo, useCallback) only for expensive work or when passing callbacks to many children. Follow the project's React and Next rules.

## Constraints

- Follow the patterns in `react-next-components.mdc` (Server Components by default, props order, event handlers, prop drilling limit, composition). For advanced React/Next patterns, refer to `.agents/skills/vercel-react-best-practices/AGENTS.md`.
- Place new components and hooks according to `project-structure.mdc`. Use `cn()` from `@/lib/styles` for class names and respect Tailwind and semantic HTML rules.

## When this rule applies

Invoke this mindset when: building new components, refactoring existing ones, deciding where to put state or hooks, designing component APIs, or splitting large components into smaller pieces.
